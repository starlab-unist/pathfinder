# PathFinder 

PathFinder is a fuzzing tool that implements the technique presented in the ICSE 2025 paper, *Lightweight Concolic Testing via Path-Condition Synthesis for Deep Learning Libraries*. It employs a lightweight approach, using approximate path conditions inferred through inductive program synthesis, to enable the exploration of diverse execution paths. You may also interested in:

- [PathFinder-artifact](https://github.com/starlab-unist/pathfinder-artifact), the artifact for the paper. It provides concrete examples of setting up and running PathFinder for testing DL libraries.

    > **NOTE**
    >
    > If you are interested in running PathFinder for PyTorch or TensorFlow, This is the right place.

- [PathFinder Driver Generator](https://github.com/starlab-unist/pathfinder-driver-generator), tool for automatically generating test drivers for PathFinder. A test driver is a code snippet required for API fuzzing, responsible for invoking the target API using the inputs generated by PathFinder.

## 1. Setup

### 1.1. Pre-built Docker Image

You can directly pull pre-built PathFinder image, by

```bash
docker pull starlabunist/pathfinder:base
# PathFinder home path = /root/pathfinder
```

### 1.2. Build from Source

Following instructions are based on an Ubuntu 22.04 environment.

#### 1.2.1. Install Prerequisites

- [Duet](https://github.com/wslee/duet)

    ```bash
    apt-get update && apt-get install -y \
        git curl bubblewrap patch make unzip \
        bzip2 opam libgmp-dev python2.7

    opam init --bare --disable-sandboxing -y

    git clone https://github.com/wslee/duet.git $HOME/duet
    cd $HOME/duet && git checkout 3f0eced
    bash build && eval $(opam env) && make

    echo "export LD_LIBRARY_PATH=~/.opam/4.08.0/lib/z3:$LD_LIBRARY_PATH" >> $HOME/.bashrc
    echo "export DUET_BIN_PATH=$HOME/duet/main.native" >> $HOME/.bashrc
    source $HOME/.bashrc
    ```

- Clang
    ```bash
    apt-get update && apt-get install -y clang
    ```

- [Z3](https://github.com/Z3Prover/z3)

    ```bash
    apt-get update && apt-get install -y cmake ninja-build

    git clone https://github.com/Z3Prover/z3.git $HOME/z3
    cd $HOME/z3 && mkdir build && cd build
    CC=clang CXX=clang++ cmake -GNinja -DCMAKE_BUILD_TYPE=Release ..
    ninja
    cmake --install .

    echo "export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH" >> $HOME/.bashrc
    source $HOME/.bashrc
    ```


#### 1.2.2. Build PathFinder

- Build

  ```bash
  git clone https://github.com/starlab-unist/pathfinder.git $HOME/pathfinder
  cd $HOME/pathfinder && mkdir build && cd build
  CC=clang CXX=clang++ cmake -GNinja -DDUET_BIN_PATH=${DUET_BIN_PATH} -DCMAKE_BUILD_TYPE=Release ..
  ninja
  cmake --install .
  ```

- Test

  ```bash
  $HOME/pathfinder/build/bin/act_test
  $HOME/pathfinder/build/bin/trace_pc_test
  ```

## 2. Usage

Similar to [LibFuzzer](https://llvm.org/docs/LibFuzzer.html), PathFinder requires a test driver, which is a code snippet responsible for invoking the target API (referred to as a fuzz target in LibFuzzer). The test driver converts the inputs generated by PathFinder into arguments for the target API and uses them to make the API call.

In this section, we provide an example of writing and running a test driver for a toy function, [`check_matmul`](./example/check_matmul.cpp).

```C++
#define DTYPE_INT   0
#define DTYPE_FLOAT 1

bool check_matmul(int a_dtype, int a_row, int a_col,
                  int b_dtype, int b_row, int b_col) {

  if (a_dtype != DTYPE_FLOAT)
    return false;

  if (a_dtype != b_dtype)
    return false;

  if (a_col != b_row)
    return false;

  return true;
}
```


### 2.1. Writing a Test Driver

The test driver for fuzzing `check_matmul` can be written as follows:

```C++
#include "pathfinder.h"
...
void PathFinderSetup() {
  PathFinderEnumArg("a_dtype", 0, 2);
  PathFinderEnumArg("b_dtype", 0, 2);
  PathFinderIntArg("a_row");
  PathFinderIntArg("a_col");
  PathFinderIntArg("b_row");
  PathFinderIntArg("b_col");

  PathFinderAddHardConstraint({
      sym_int_arg["a_row"] >= 1,
      sym_int_arg["a_col"] >= 1,
      sym_int_arg["b_row"] >= 1,
      sym_int_arg["b_col"] >= 1,
  });
}

int PathFinderTestOneInput(const pathfinder::Input& x) {
  
  PathFinderExecuteTarget(
    check_matmul(
      x["a_dtype"], x["a_row"], x["a_col"],
      x["b_dtype"], x["b_row"], x["b_col"]));

  return 0;
}
```
- `#include "pathfinder.h"`: Includes PathFinder header.
- `PathFinderSetup`: Provides PathFinder with the types of arguments and their constraints.
  - `PathFinderEnumArg`: Specifies an argument with a limited range of possible values. `PathFinderEnumArg("a_dtype", 0, 2)` indicates that the argument `a_dtype` can take values from 0 to 1 (i.e., `0` + `2` - 1).
  - `PathFinderIntArg`: Specifies an integer argument.
  - `PathFinderAddHardConstraint`: Specifies the hard constraints for arguments. PathFinder generates inputs that strictly adhere to these constraints.
- `PathFinderTestOneInput`: A callback executed in every iteration of PathFinder. It uses the input `x` generated by PathFinder to invoke the target function. The code section of interest (usually the target function) **must** be wrapped with the `PathFinderExecuteTarget` macro.

### 2.2. Running Driver Binary

```bash
# Assuming PathFinder dir is ~/pathfinder,

~/pathfinder/build/bin/check_matmul --max_total_time 1
```

- Useful Flags
  - `--min`: Defines the minimum value for integer arguments.
  - `--max`: Defines the maximum value for integer arguments.
  - `--iter`: Set the maximum number of iteration.
  - `--max_total_time`: Set the maximum running time in seconds.
  - `--verbose`: If set to 1, prints the prefix tree.
  - `--help`: Prints all flags.

If executed with the `--verbose 1` flag, a prefix tree (a tree of execution paths with approximate path conditions) like the one below will be displayed.

```bash
cond: NEGLECT
    cond: a_dtype ∉ {1}
    input: {(0,0,2,2,2,2)}
    cond: a_dtype ∉ {0}
        cond: b_dtype ∉ {1}
        input: {(1,0,1,1,1,1)}
        cond: b_dtype ∉ {0}
            cond: (!= a_col b_row)
            input: {(1,1,1,1,3,1),
                    (1,1,1,3,1,1)}
            cond: (= a_col b_row)
            input: {(1,1,1,1,1,1),
                    (1,1,2,2,2,2),
                    (1,1,1,3,3,2)}

Found paths: 4
Total number of generation: 6003
Number of instrumented PCs: 2401
Number of covered PCs: 314
Total elpased time: 2000 ms
```

## 3. How to Import PathFinder

PathFinder is installed on the system via CMake, allowing it to be easily imported into any C++ project. However, before proceeding, the following two considerations must be addressed.

1. To perform fuzzing with PathFinder, the target library **must** be instrumented using Clang's `-fsanitize-coverage=edge,no-prune,trace-pc-guard` flags ([Clang SanitizerCoverage](https://clang.llvm.org/docs/SanitizerCoverage.html)).

1. To maximize fuzzing efficiency, it is **highly recommended** to disable optimizations (i.e., set `-O0` flag.), as optimized CFG can significantly reduce the accuracy of approxmiate path conditions.

### 3.1. C++ Project w/ CMake

```cmake
find_package(pathfinder)
...
target_link_libraries(DRIVER_YOU_WROTE PRIVATE pathfinder)
```
Importing PathFinder into a C++ project that uses CMake is straightforward. Simply use `find_package` to import PathFinder and link it to the driver target using `target_link_libraries`.

When building the project and test driver, use `CXXFLAGS=-fsanitize-coverage=edge,no-prune,trace-pc-guard` for instrumentation and `-DCMAKE_BUILD_TYPE=Debug` to disable optimizations.

### 3.2. C++ Project w/o CMake

In this case, both Z3 and PathFinder must be specified using compiler flags:

- Include Flags:
  - `-I/usr/local/include`: Includes Z3 headers.
  - `-I/usr/local/include/pathfinder`: Includes PathFinder headers.
- Linker Flags:
  - `-L/usr/local/lib -lz3`: Links Z3.
  - `-L/usr/local/lib/pathfinder -lpathfinder`: Links PathFinder.

To emphasize again, it is essential to instrument both the target library and test driver with the `-fsanitize-coverage=edge,no-prune,trace-pc-guard` flags and to disable optimizations using the `-O0` flag.
